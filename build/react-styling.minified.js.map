{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///react-styling.minified.js","webpack:///webpack/bootstrap 8f19bffeea788c7f8f3a","webpack:///G:/work/react-styling/source/index.js","webpack:///G:/work/react-styling/source/helpers.js","webpack:///G:/work/react-styling/source/tabulator.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","styler","strings","style","i","length","_len","arguments","values","Array","_key","_helpers","exists","parse_style_json_object","text","replace","lines","split","tabulator","_tabulator2","determine_tabulation","style_json","parse_node_json","extract_tabulation","expand_modifier_style_classes","styles","children_lines","style_object","map","key","substring","indexOf","trim","value","character","toUpperCase","String","parseInt","parseFloat","reduce","extend","parse_children","filter_lines_for_parsing","split_lines_by_child_nodes","name","shift","line","is_a_modifier","starts_with","ends_with","filter","tabs","colon_index","forEach","json","_is_a_modifier","nodes","node","is_blank","node_entry_lines","index","node_ending_lines","line_index","push","from_to","zip","slice","get_node_style","pseudo_classes","get_node_pseudo_classes","Object","keys","property","style_property","defineProperty","_tabulator","string","what","lastIndexOf","repeat","times","result","a","b","_","_this","_arguments","_again","objects","to","from","last","intermediary_result","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","err","pop","apply","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","protoProps","staticProps","prototype","Tabulator","tab","how_much","symbol","matches","match","regexp","calculate_indentation","pure_line","reduce_indentation","reason","Error","reveal_whitespace","original_line","minimum_indentation","minimum","Math","min","Infinity","whitespace_count","whitespace","regexp_anywhere","rest","is_tabulated","_tab","RegExp","calculate_leading_spaces","counter","substract","pair","_tab2","tab_width","abs","spaced_tab"],"mappings":"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","file":"react-styling.minified.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"react-styling\"] = factory();\n\telse\n\t\troot[\"react-styling\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"react-styling\"] = factory();\n\telse\n\t\troot[\"react-styling\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t\tvalue: true\n\t});\n\texports['default'] = styler;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _helpers = __webpack_require__(1);\n\t\n\tvar _tabulator = __webpack_require__(2);\n\t\n\tvar _tabulator2 = _interopRequireDefault(_tabulator);\n\t\n\t// using ES6 template strings\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings\n\t\n\tfunction styler(strings) {\n\t\tvar style = '';\n\t\n\t\t// restore the whole string from \"strings\" and \"values\" parts\n\t\tvar i = 0;\n\t\twhile (i < strings.length) {\n\t\t\tstyle += strings[i];\n\t\n\t\t\tfor (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\t\t\tvalues[_key - 1] = arguments[_key];\n\t\t\t}\n\t\n\t\t\tif ((0, _helpers.exists)(values[i])) {\n\t\t\t\tstyle += values[i];\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\n\t\treturn parse_style_json_object(style);\n\t}\n\t\n\t// converts text to JSON object\n\tfunction parse_style_json_object(text) {\n\t\t// remove multiline comments\n\t\ttext = text.replace(/\\/\\*([\\s\\S]*?)\\*\\//g, '');\n\t\n\t\t// ignore curly braces for now.\n\t\t// maybe support curly braces along with tabulation in future\n\t\ttext = text.replace(/[\\{\\}]/g, '');\n\t\n\t\tvar lines = text.split('\\n');\n\t\n\t\t// helper class for dealing with tabulation\n\t\tvar tabulator = new _tabulator2['default'](_tabulator2['default'].determine_tabulation(lines));\n\t\n\t\t// parse text into JSON object\n\t\tvar style_json = parse_node_json([], tabulator.extract_tabulation(lines));\n\t\n\t\t// expand \"modifier\" style classes\n\t\treturn expand_modifier_style_classes(style_json);\n\t}\n\t\n\t// parse child nodes' lines (and this node's styles) into this node's style JSON object\n\tfunction parse_node_json(styles, children_lines) {\n\t\t// transform this node's style lines from text to JSON properties and their values\n\t\tvar style_object = styles.map(function (style) {\n\t\t\tvar key = style.substring(0, style.indexOf(':')).trim();\n\t\t\tvar value = style.substring(style.indexOf(':') + ':'.length).trim();\n\t\n\t\t\t// transform dashed key to camelCase key (it's required by React)\n\t\t\tkey = key.replace(/([-]{1}[a-z]{1})/g, function (character) {\n\t\t\t\treturn character.substring(1).toUpperCase();\n\t\t\t});\n\t\n\t\t\t// support old CSS syntax\n\t\t\tvalue = value.replace(/;$/, '').trim();\n\t\n\t\t\t// check if the value can be parsed into an integer\n\t\t\tif (String(parseInt(value)) === value) {\n\t\t\t\tvalue = parseInt(value);\n\t\t\t}\n\t\n\t\t\t// check if the value can be parsed into a float\n\t\t\tif (String(parseFloat(value)) === value) {\n\t\t\t\tvalue = parseFloat(value);\n\t\t\t}\n\t\n\t\t\treturn { key: key, value: value };\n\t\t})\n\t\t// combine the styles into a JSON object\n\t\t.reduce(function (styles, style) {\n\t\t\tstyles[style.key] = style.value;\n\t\t\treturn styles;\n\t\t}, {});\n\t\n\t\t// parse child nodes and add them to this node's JSON object\n\t\treturn (0, _helpers.extend)(style_object, parse_children(children_lines));\n\t}\n\t\n\t// parses child nodes' lines of text into the corresponding child node JSON objects\n\tfunction parse_children(lines) {\n\t\t// preprocess the lines (filter out comments, blank lines, etc)\n\t\tlines = filter_lines_for_parsing(lines);\n\t\n\t\t// return empty object if there are no lines to parse\n\t\tif (lines.length === 0) {\n\t\t\treturn {};\n\t\t}\n\t\n\t\t// parse each child node's lines\n\t\treturn split_lines_by_child_nodes(lines).map(function (lines) {\n\t\t\t// the first line is this child node's name\n\t\t\tvar name = lines.shift().line;\n\t\n\t\t\t// is it a \"modifier\" style class\n\t\t\tvar is_a_modifier = false;\n\t\n\t\t\t// detect modifier style classes\n\t\t\tif ((0, _helpers.starts_with)(name, '&')) {\n\t\t\t\tname = name.substring('&'.length);\n\t\t\t\tis_a_modifier = true;\n\t\t\t}\n\t\n\t\t\t// support old-school CSS syntax\n\t\t\tif ((0, _helpers.starts_with)(name, '.')) {\n\t\t\t\tname = name.substring('.'.length);\n\t\t\t}\n\t\n\t\t\t// if someone forgot a trailing colon in the style class name - trim it\n\t\t\t// (or maybe these are Python people)\n\t\t\tif ((0, _helpers.ends_with)(name, ':')) {\n\t\t\t\tname = name.substring(0, name.length - ':'.length)\n\t\t\t\t// throw new Error(`Remove the trailing colon at line: ${original_line}`)\n\t\t\t\t;\n\t\t\t}\n\t\n\t\t\t// this child node's styles\n\t\t\tvar styles = lines.filter(function (line) {\n\t\t\t\t// styles always have indentation of 2\n\t\t\t\tif (line.tabs !== 2) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\n\t\t\t\t// detect generic css style line (skip modifier classes and media queries)\n\t\t\t\tvar colon_index = line.line.indexOf(':');\n\t\t\t\treturn !(0, _helpers.starts_with)(line.line, '&') && !(0, _helpers.starts_with)(line.line, '@') && (colon_index > 0 && colon_index < line.line.length - 1);\n\t\t\t});\n\t\n\t\t\t// the lines corresponding to this child node's child nodes and all their children, etc\n\t\t\tvar children_lines = lines.filter(function (line) {\n\t\t\t\treturn styles.indexOf(line) < 0;\n\t\t\t});\n\t\n\t\t\t// convert style lines info to just text lines\n\t\t\tstyles = styles.map(function (line) {\n\t\t\t\treturn line.line;\n\t\t\t});\n\t\n\t\t\t// reduce tabulation for this child node's child nodes' lines\n\t\t\tchildren_lines.forEach(function (line) {\n\t\t\t\treturn line.tabs--;\n\t\t\t});\n\t\n\t\t\t// using this child node's style lines\n\t\t\t// and this child node's child nodes' lines,\n\t\t\t// generate this child node's style JSON object\n\t\t\t// (this is gonna be a recursion)\n\t\t\tvar json = parse_node_json(styles, children_lines);\n\t\n\t\t\t// set the modifier flag if it's the case\n\t\t\tif (is_a_modifier) {\n\t\t\t\tjson._is_a_modifier = true;\n\t\t\t}\n\t\n\t\t\t// this child node's style JSON object is ready\n\t\t\treturn { name: name, json: json };\n\t\t})\n\t\t// combine all the child nodes into a single JSON object\n\t\t.reduce(function (nodes, node) {\n\t\t\tnodes[node.name] = node.json;\n\t\t\treturn nodes;\n\t\t}, {});\n\t}\n\t\n\t// filters out commets, blank lines, etc\n\tfunction filter_lines_for_parsing(lines) {\n\t\t// filter out blank lines\n\t\tlines = lines.filter(function (line) {\n\t\t\treturn !(0, _helpers.is_blank)(line.line);\n\t\t});\n\t\n\t\tlines.forEach(function (line) {\n\t\t\t// remove single line comments\n\t\t\tline.line = line.line.replace(/^\\s*\\/\\/.*/, '');\n\t\t\t// remove any trailing whitespace\n\t\t\tline.line = line.line.trim();\n\t\t});\n\t\n\t\treturn lines;\n\t}\n\t\n\t// takes the whole lines array and splits it by its top-tier child nodes\n\tfunction split_lines_by_child_nodes(lines) {\n\t\t// determine lines with indentation = 1 (child node entry lines)\n\t\tvar node_entry_lines = lines.map(function (line, index) {\n\t\t\treturn { tabs: line.tabs, index: index };\n\t\t}).filter(function (line) {\n\t\t\treturn line.tabs === 1;\n\t\t}).map(function (line) {\n\t\t\treturn line.index;\n\t\t});\n\t\n\t\t// deduce corresponding child node ending lines\n\t\tvar node_ending_lines = node_entry_lines.map(function (line_index) {\n\t\t\treturn line_index - 1;\n\t\t});\n\t\tnode_ending_lines.shift();\n\t\tnode_ending_lines.push(lines.length - 1);\n\t\n\t\t// each child node boundaries in terms of starting line index and ending line index\n\t\tvar from_to = (0, _helpers.zip)(node_entry_lines, node_ending_lines);\n\t\n\t\t// now lines are split by child nodes\n\t\treturn from_to.map(function (from_to) {\n\t\t\treturn lines.slice(from_to[0], from_to[1] + 1);\n\t\t});\n\t}\n\t\n\t// expand modifier style classes\n\tfunction expand_modifier_style_classes(node) {\n\t\tvar style = get_node_style(node);\n\t\tvar pseudo_classes = get_node_pseudo_classes(node);\n\t\n\t\tObject.keys(node)\n\t\t// get all modifier style class nodes\n\t\t.filter(function (name) {\n\t\t\treturn typeof node[name] === 'object' && node[name]._is_a_modifier;\n\t\t})\n\t\t// for each modifier style class node\n\t\t.forEach(function (name) {\n\t\t\t// delete the modifier flags\n\t\t\tdelete node[name]._is_a_modifier;\n\t\n\t\t\t// include parent node's styles and pseudo-classes into the modifier style class node\n\t\t\tnode[name] = (0, _helpers.extend)({}, style, pseudo_classes, node[name]);\n\t\t});\n\t\n\t\tObject.keys(node)\n\t\t// get all style class nodes\n\t\t.filter(function (name) {\n\t\t\treturn typeof node[name] === 'object';\n\t\t})\n\t\t// for each style class node\n\t\t.forEach(function (name) {\n\t\t\t// recurse\n\t\t\texpand_modifier_style_classes(node[name]);\n\t\t});\n\t\n\t\treturn node;\n\t}\n\t\n\t// extracts root css styles of this style class node\n\tfunction get_node_style(node) {\n\t\treturn Object.keys(node)\n\t\t// get all CSS styles of this style class node\n\t\t.filter(function (property) {\n\t\t\treturn typeof node[property] !== 'object';\n\t\t})\n\t\t// for each CSS style of this style class node\n\t\t.reduce(function (style, style_property) {\n\t\t\tstyle[style_property] = node[style_property];\n\t\t\treturn style;\n\t\t}, {});\n\t}\n\t\n\t// extracts root pseudo-classes of this style class node\n\tfunction get_node_pseudo_classes(node) {\n\t\treturn Object.keys(node)\n\t\t// get all child style classes this style class node, which start with a colon and aren't modifiers\n\t\t.filter(function (property) {\n\t\t\treturn typeof node[property] === 'object' && ((0, _helpers.starts_with)(property, ':') || (0, _helpers.starts_with)(property, '@')) && !node[property]._is_a_modifier;\n\t\t})\n\t\t// for each child style class of this style class node\n\t\t.reduce(function (pseudo_classes, name) {\n\t\t\tpseudo_classes[name] = node[name];\n\t\t\treturn pseudo_classes;\n\t\t}, {});\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t// if the variable is defined\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t\tvalue: true\n\t});\n\texports.starts_with = starts_with;\n\texports.ends_with = ends_with;\n\texports.repeat = repeat;\n\texports.is_blank = is_blank;\n\texports.zip = zip;\n\texports.extend = extend;\n\tvar exists = function exists(what) {\n\t\treturn typeof what !== 'undefined';\n\t};\n\t\n\texports.exists = exists;\n\t// if the string starts with the substring\n\t\n\tfunction starts_with(string, what) {\n\t\treturn string.indexOf(what) === 0;\n\t}\n\t\n\t// if the string ends with the substring\n\t\n\tfunction ends_with(string, what) {\n\t\tvar index = string.lastIndexOf(what);\n\t\tif (index < 0) {\n\t\t\treturn;\n\t\t}\n\t\treturn index === string.length - what.length;\n\t}\n\t\n\t// repeat string N times\n\t\n\tfunction repeat(what, times) {\n\t\tvar result = '';\n\t\twhile (times > 0) {\n\t\t\tresult += what;\n\t\t\ttimes--;\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t// if the text is blank\n\t\n\tfunction is_blank(text) {\n\t\treturn !exists(text) || !text.replace(/\\s/g, '');\n\t}\n\t\n\t// zips two arrays\n\t\n\tfunction zip(a, b) {\n\t\treturn a.map(function (_, index) {\n\t\t\treturn [a[index], b[index]];\n\t\t});\n\t}\n\t\n\t// extends the first object with\n\t/* istanbul ignore next: some weird transpiled code, not testable */\n\t\n\tfunction extend() {\n\t\tvar _this = this,\n\t\t    _arguments = arguments;\n\t\n\t\tvar _again = true;\n\t\n\t\t_function: while (_again) {\n\t\t\t_len = objects = _key = to = from = last = intermediary_result = _iteratorNormalCompletion = _didIteratorError = _iteratorError = undefined;\n\t\t\t_again = false;\n\t\n\t\t\tfor (var _len = _arguments.length, objects = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t\tobjects[_key] = _arguments[_key];\n\t\t\t}\n\t\n\t\t\tvar to = objects[0];\n\t\t\tvar from = objects[1];\n\t\n\t\t\tif (objects.length > 2) {\n\t\t\t\tvar last = objects.pop();\n\t\t\t\tvar intermediary_result = extend.apply(_this, objects);\n\t\t\t\t_this = undefined;\n\t\t\t\t_arguments = [intermediary_result, last];\n\t\t\t\t_again = true;\n\t\t\t\tcontinue _function;\n\t\t\t}\n\t\n\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\tvar _didIteratorError = false;\n\t\t\tvar _iteratorError = undefined;\n\t\n\t\t\ttry {\n\t\t\t\tfor (var _iterator = Object.keys(from)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\tvar key = _step.value;\n\t\n\t\t\t\t\tif (typeof from[key] === 'object' && exists(to[key])) {\n\t\t\t\t\t\tto[key] = extend(to[key], from[key]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tto[key] = from[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError = true;\n\t\t\t\t_iteratorError = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator['return']) {\n\t\t\t\t\t\t_iterator['return']();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn to;\n\t\t}\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _helpers = __webpack_require__(1);\n\t\n\t// tabulation utilities\n\t\n\tvar Tabulator = (function () {\n\t\tfunction Tabulator(tab) {\n\t\t\t_classCallCheck(this, Tabulator);\n\t\n\t\t\tthis.tab = tab;\n\t\t}\n\t\n\t\t_createClass(Tabulator, [{\n\t\t\tkey: 'reduce_indentation',\n\t\n\t\t\t// remove some tabs in the beginning\n\t\t\tvalue: function reduce_indentation(line, how_much) {\n\t\t\t\treturn line.substring(this.tab.symbol.length * how_much);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'calculate_indentation',\n\t\n\t\t\t// how many \"tabs\" are there before content of this line\n\t\t\tvalue: function calculate_indentation(line) {\n\t\t\t\tvar matches = line.match(this.tab.regexp);\n\t\n\t\t\t\tif (!matches) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\n\t\t\t\treturn matches[0].length / this.tab.symbol.length;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'extract_tabulation',\n\t\t\tvalue: function extract_tabulation(lines) {\n\t\t\t\tvar _this = this;\n\t\n\t\t\t\tlines = lines\n\t\t\t\t// preserve line indexes\n\t\t\t\t.map(function (line, index) {\n\t\t\t\t\treturn { line: line, index: index };\n\t\t\t\t})\n\t\t\t\t// filter out blank lines\n\t\t\t\t.filter(function (line) {\n\t\t\t\t\treturn !(0, _helpers.is_blank)(line.line);\n\t\t\t\t});\n\t\n\t\t\t\t// calculate each line's indentation\n\t\t\t\tlines.forEach(function (line) {\n\t\t\t\t\tvar tabs = _this.calculate_indentation(line.line);\n\t\t\t\t\tvar pure_line = _this.reduce_indentation(line.line, tabs);\n\t\n\t\t\t\t\t// check for messed up space indentation\n\t\t\t\t\tif ((0, _helpers.starts_with)(pure_line, ' ')) {\n\t\t\t\t\t\tvar reason = undefined;\n\t\t\t\t\t\tif (_this.tab.symbol === '\\t') {\n\t\t\t\t\t\t\treason = 'mixed tabs and spaces';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treason = 'extra leading spaces';\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tthrow new Error('Invalid indentation (' + reason + ') at line ' + line.index + ': \"' + _this.reveal_whitespace(line.line) + '\"');\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// check for tabs in spaced intentation\n\t\t\t\t\tif ((0, _helpers.starts_with)(pure_line, '\\t')) {\n\t\t\t\t\t\tvar reason = undefined;\n\t\t\t\t\t\tif (_this.tab.symbol === '\\t') {\n\t\t\t\t\t\t\treason = 'extra leading tabs';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treason = 'mixed tabs and spaces';\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tthrow new Error('Invalid indentation (' + reason + ') at line ' + line.index + ': \"' + _this.reveal_whitespace(line.line) + '\"');\n\t\t\t\t\t}\n\t\n\t\t\t\t\tline.tabs = tabs;\n\t\t\t\t\tline.original_line = line.line;\n\t\t\t\t\tline.line = pure_line;\n\t\t\t\t});\n\t\n\t\t\t\t// get the minimum indentation level\n\t\t\t\tvar minimum_indentation = lines.reduce(function (minimum, line) {\n\t\t\t\t\treturn Math.min(minimum, line.tabs);\n\t\t\t\t}, Infinity);\n\t\n\t\t\t\t/* istanbul ignore else: do nothing on else */\n\t\t\t\t// if there is initial tabulation missing - add it\n\t\t\t\tif (minimum_indentation === 0) {\n\t\t\t\t\tlines.forEach(function (line) {\n\t\t\t\t\t\tline.tabs++;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t// if there is excessive tabulation - trim it\n\t\t\t\telse if (minimum_indentation > 1) {\n\t\t\t\t\tlines.forEach(function (line) {\n\t\t\t\t\t\tline.tabs -= minimum_indentation - 1;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\n\t\t\t\t// check for messed up tabulation\n\t\t\t\tif (lines[0].tabs !== 1) {\n\t\t\t\t\tthrow new Error('Invalid indentation at line ' + lines[0].index + ': \"' + lines[0].original_line + '\"');\n\t\t\t\t}\n\t\n\t\t\t\treturn lines;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'reveal_whitespace',\n\t\t\tvalue: function reveal_whitespace(text) {\n\t\t\t\tvar whitespace_count = text.length - text.replace(/^\\s*/, '').length;\n\t\n\t\t\t\tvar whitespace = text.substring(0, whitespace_count + 1).replace(this.tab.regexp_anywhere, '[indent]').replace(/ /g, '[space]').replace(/\\t/g, '[tab]');\n\t\n\t\t\t\tvar rest = text.substring(whitespace_count + 1);\n\t\n\t\t\t\treturn whitespace + rest;\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Tabulator;\n\t})();\n\t\n\texports['default'] = Tabulator;\n\t\n\t// decide whether it's tabs or spaces\n\tTabulator.determine_tabulation = function (lines) {\n\t\tvar substract = function substract(pair) {\n\t\t\treturn pair[0] - pair[1];\n\t\t};\n\t\n\t\tfunction is_tabulated(line) {\n\t\t\t// if we're using tabs for tabulation\n\t\t\tif ((0, _helpers.starts_with)(line, '\\t')) {\n\t\t\t\tvar _tab = {\n\t\t\t\t\tsymbol: '\\t',\n\t\t\t\t\tregexp: new RegExp('^(\\t)+', 'g'),\n\t\t\t\t\tregexp_anywhere: new RegExp('(\\t)+', 'g')\n\t\t\t\t};\n\t\n\t\t\t\treturn _tab;\n\t\t\t}\n\t\t}\n\t\n\t\tfunction calculate_leading_spaces(line) {\n\t\t\tvar counter = 0;\n\t\t\tline.replace(/^( )+/g, function (match) {\n\t\t\t\tcounter = match.length;\n\t\t\t});\n\t\t\treturn counter;\n\t\t}\n\t\n\t\t// take all meaningful lines\n\t\tlines = lines.filter(function (line) {\n\t\t\treturn !(0, _helpers.is_blank)(line);\n\t\t});\n\t\n\t\t// has to be at least two of them\n\t\tif (lines.length === 0) {\n\t\t\tthrow new Error('Couldn\\'t decide on tabulation type. Not enough lines.');\n\t\t}\n\t\n\t\t/* istanbul ignore next: not a probable case in styles scenario */\n\t\tif (lines.length === 1) {\n\t\t\tvar _tab2 = is_tabulated(lines[0]);\n\t\t\tif (_tab2) {\n\t\t\t\treturn _tab2;\n\t\t\t}\n\t\n\t\t\treturn calculate_leading_spaces(lines[0]);\n\t\t}\n\t\n\t\t// if we're using tabs for tabulation\n\t\tvar tab = is_tabulated(lines[1]);\n\t\tif (tab) {\n\t\t\treturn tab;\n\t\t}\n\t\n\t\t// take the first two lines,\n\t\t// calculate their indentation,\n\t\t// substract it and you've got the tab width\n\t\tvar tab_width = Math.abs(substract(lines.slice(0, 2).map(calculate_leading_spaces)));\n\t\n\t\tif (tab_width === 0) {\n\t\t\tthrow new Error('Couldn\\'t decide on tabulation type. Same indentation.');\n\t\t}\n\t\n\t\tvar symbol = (0, _helpers.repeat)(' ', tab_width);\n\t\n\t\tvar spaced_tab = {\n\t\t\tsymbol: symbol,\n\t\t\tregexp: new RegExp('^(' + symbol + ')+', 'g'),\n\t\t\tregexp_anywhere: new RegExp('(' + symbol + ')+', 'g')\n\t\t};\n\t\n\t\treturn spaced_tab;\n\t};\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** react-styling.minified.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 8f19bffeea788c7f8f3a\n **/","import { exists, starts_with, ends_with, is_blank, zip, extend } from './helpers'\r\nimport Tabulator from './tabulator'\r\n\r\n// using ES6 template strings\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings\r\nexport default function styler(strings, ...values)\r\n{\r\n\tlet style = ''\r\n\r\n\t// restore the whole string from \"strings\" and \"values\" parts\r\n\tlet i = 0\r\n\twhile (i < strings.length)\r\n\t{\r\n\t\tstyle += strings[i]\r\n\t\tif (exists(values[i]))\r\n\t\t{\r\n\t\t\tstyle += values[i]\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\r\n\treturn parse_style_json_object(style)\r\n}\r\n\r\n// converts text to JSON object\r\nfunction parse_style_json_object(text)\r\n{\r\n\t// remove multiline comments\r\n\ttext = text.replace(/\\/\\*([\\s\\S]*?)\\*\\//g, '')\r\n\r\n\t// ignore curly braces for now.\r\n\t// maybe support curly braces along with tabulation in future\r\n\ttext = text.replace(/[\\{\\}]/g, '')\r\n\r\n\tconst lines = text.split('\\n')\r\n\r\n\t// helper class for dealing with tabulation\r\n\tconst tabulator = new Tabulator(Tabulator.determine_tabulation(lines))\r\n\r\n\t// parse text into JSON object\r\n\tconst style_json = parse_node_json([], tabulator.extract_tabulation(lines))\r\n\r\n\t// expand \"modifier\" style classes\r\n\treturn expand_modifier_style_classes(style_json)\r\n}\r\n\r\n// parse child nodes' lines (and this node's styles) into this node's style JSON object\r\nfunction parse_node_json(styles, children_lines)\r\n{\r\n\t// transform this node's style lines from text to JSON properties and their values\r\n\tconst style_object = styles.map(function(style)\r\n\t{\r\n\t\tlet key   = style.substring(0, style.indexOf(':')).trim()\r\n\t\tlet value = style.substring(style.indexOf(':') + ':'.length).trim()\r\n\r\n\t\t// transform dashed key to camelCase key (it's required by React)\r\n\t\tkey = key.replace(/([-]{1}[a-z]{1})/g, character => character.substring(1).toUpperCase())\r\n\r\n\t\t// support old CSS syntax\r\n\t\tvalue = value.replace(/;$/, '').trim()\r\n\r\n\t\t// check if the value can be parsed into an integer\r\n\t\tif (String(parseInt(value)) === value)\r\n\t\t{\r\n\t\t\tvalue = parseInt(value)\r\n\t\t}\r\n\r\n\t\t// check if the value can be parsed into a float\r\n\t\tif (String(parseFloat(value)) === value)\r\n\t\t{\r\n\t\t\tvalue = parseFloat(value)\r\n\t\t}\r\n\r\n\t\treturn { key, value }\r\n\t})\r\n\t// combine the styles into a JSON object\r\n\t.reduce(function(styles, style)\r\n\t{\r\n\t\tstyles[style.key] = style.value\r\n\t\treturn styles\r\n\t}, \r\n\t{})\r\n\r\n\t// parse child nodes and add them to this node's JSON object\r\n\treturn extend(style_object, parse_children(children_lines))\r\n}\r\n\r\n// parses child nodes' lines of text into the corresponding child node JSON objects\r\nfunction parse_children(lines)\r\n{\r\n\t// preprocess the lines (filter out comments, blank lines, etc)\r\n\tlines = filter_lines_for_parsing(lines)\r\n\r\n\t// return empty object if there are no lines to parse\r\n\tif (lines.length === 0)\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// parse each child node's lines\r\n\treturn split_lines_by_child_nodes(lines).map(function(lines)\r\n\t{\r\n\t\t// the first line is this child node's name\r\n\t\tlet name = lines.shift().line\r\n\r\n\t\t// is it a \"modifier\" style class\r\n\t\tlet is_a_modifier = false\r\n\r\n\t\t// detect modifier style classes\r\n\t\tif (starts_with(name, '&'))\r\n\t\t{\r\n\t\t\tname = name.substring('&'.length)\r\n\t\t\tis_a_modifier = true\r\n\t\t}\r\n\r\n\t\t// support old-school CSS syntax\r\n\t\tif (starts_with(name, '.'))\r\n\t\t{\r\n\t\t\tname = name.substring('.'.length)\r\n\t\t}\r\n\r\n\t\t// if someone forgot a trailing colon in the style class name - trim it\r\n\t\t// (or maybe these are Python people)\r\n\t\tif (ends_with(name, ':'))\r\n\t\t{\r\n\t\t\tname = name.substring(0, name.length - ':'.length)\r\n\t\t\t// throw new Error(`Remove the trailing colon at line: ${original_line}`)\r\n\t\t}\r\n\r\n\t\t// this child node's styles\r\n\t\tlet styles = lines.filter(function(line)\r\n\t\t{\r\n\t\t\t// styles always have indentation of 2\r\n\t\t\tif (line.tabs !== 2)\r\n\t\t\t{\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\r\n\t\t\t// detect generic css style line (skip modifier classes and media queries)\r\n\t\t\tconst colon_index = line.line.indexOf(':')\r\n\t\t\treturn !starts_with(line.line, '&') \r\n\t\t\t\t&& !starts_with(line.line, '@') \r\n\t\t\t\t&& (colon_index > 0 && colon_index < line.line.length - 1)\r\n\t\t})\r\n\r\n\t\t// the lines corresponding to this child node's child nodes and all their children, etc\r\n\t\tconst children_lines = lines.filter(line => styles.indexOf(line) < 0)\r\n\r\n\t\t// convert style lines info to just text lines\r\n\t\tstyles = styles.map(line => line.line)\r\n\r\n\t\t// reduce tabulation for this child node's child nodes' lines\r\n\t\tchildren_lines.forEach(line => line.tabs--)\r\n\r\n\t\t// using this child node's style lines \r\n\t\t// and this child node's child nodes' lines,\r\n\t\t// generate this child node's style JSON object\r\n\t\t// (this is gonna be a recursion)\r\n\t\tconst json = parse_node_json(styles, children_lines)\r\n\r\n\t\t// set the modifier flag if it's the case\r\n\t\tif (is_a_modifier)\r\n\t\t{\r\n\t\t\tjson._is_a_modifier = true\r\n\t\t}\r\n\r\n\t\t// this child node's style JSON object is ready\r\n\t\treturn { name, json }\r\n\t})\r\n\t// combine all the child nodes into a single JSON object\r\n\t.reduce(function(nodes, node)\r\n\t{\r\n\t\tnodes[node.name] = node.json\r\n\t\treturn nodes\r\n\t}, \r\n\t{})\r\n}\r\n\r\n// filters out commets, blank lines, etc\r\nfunction filter_lines_for_parsing(lines)\r\n{\r\n\t// filter out blank lines\r\n\tlines = lines.filter(line => !is_blank(line.line))\r\n\r\n\tlines.forEach(function(line)\r\n\t{\r\n\t\t// remove single line comments\r\n\t\tline.line = line.line.replace(/^\\s*\\/\\/.*/, '')\r\n\t\t// remove any trailing whitespace\r\n\t\tline.line = line.line.trim()\r\n\t})\r\n\r\n\treturn lines\r\n}\r\n\r\n// takes the whole lines array and splits it by its top-tier child nodes\r\nfunction split_lines_by_child_nodes(lines)\r\n{\r\n\t// determine lines with indentation = 1 (child node entry lines)\r\n\tconst node_entry_lines = lines.map((line, index) => \r\n\t{\r\n\t\treturn { tabs: line.tabs, index }\r\n\t})\r\n\t.filter(line => line.tabs === 1)\r\n\t.map(line => line.index)\r\n\r\n\t// deduce corresponding child node ending lines\r\n\tconst node_ending_lines = node_entry_lines.map(line_index => line_index - 1)\r\n\tnode_ending_lines.shift()\r\n\tnode_ending_lines.push(lines.length - 1)\r\n\r\n\t// each child node boundaries in terms of starting line index and ending line index\r\n\tconst from_to = zip(node_entry_lines, node_ending_lines)\r\n\r\n\t// now lines are split by child nodes\r\n\treturn from_to.map(from_to => lines.slice(from_to[0], from_to[1] + 1))\r\n}\r\n\r\n// expand modifier style classes\r\nfunction expand_modifier_style_classes(node)\r\n{\r\n\tconst style          = get_node_style(node)\r\n\tconst pseudo_classes = get_node_pseudo_classes(node)\r\n\r\n\tObject.keys(node)\r\n\t// get all modifier style class nodes\r\n\t.filter(name => typeof(node[name]) === 'object' && node[name]._is_a_modifier)\r\n\t// for each modifier style class node\r\n\t.forEach(function(name)\r\n\t{\r\n\t\t// delete the modifier flags\r\n\t\tdelete node[name]._is_a_modifier\r\n\r\n\t\t// include parent node's styles and pseudo-classes into the modifier style class node\r\n\t\tnode[name] = extend({}, style, pseudo_classes, node[name])\r\n\t})\r\n\r\n\tObject.keys(node)\r\n\t// get all style class nodes\r\n\t.filter(name => typeof(node[name]) === 'object')\r\n\t// for each style class node\r\n\t.forEach(function(name)\r\n\t{\r\n\t\t// recurse\r\n\t\texpand_modifier_style_classes(node[name])\r\n\t})\r\n\r\n\treturn node\r\n}\r\n\r\n// extracts root css styles of this style class node\r\nfunction get_node_style(node)\r\n{\r\n\treturn Object.keys(node)\r\n\t// get all CSS styles of this style class node\r\n\t.filter(property => typeof(node[property]) !== 'object')\r\n\t// for each CSS style of this style class node\r\n\t.reduce(function(style, style_property)\r\n\t{\r\n\t\tstyle[style_property] = node[style_property]\r\n\t\treturn style\r\n\t}, \r\n\t{})\r\n}\r\n\r\n// extracts root pseudo-classes of this style class node\r\nfunction get_node_pseudo_classes(node)\r\n{\r\n\treturn Object.keys(node)\r\n\t// get all child style classes this style class node, which start with a colon and aren't modifiers\r\n\t.filter(property => typeof(node[property]) === 'object' \r\n\t\t&& (starts_with(property, ':') || starts_with(property, '@')) \r\n\t\t&& !node[property]._is_a_modifier)\r\n\t// for each child style class of this style class node\r\n\t.reduce(function(pseudo_classes, name)\r\n\t{\r\n\t\tpseudo_classes[name] = node[name]\r\n\t\treturn pseudo_classes\r\n\t}, \r\n\t{})\r\n}\n\n\n/** WEBPACK FOOTER **\n ** G:/work/react-styling/source/index.js\n **/","// if the variable is defined\nexport const exists = what => typeof what !== 'undefined'\n\n// if the string starts with the substring\nexport function starts_with(string, what)\n{\n\treturn string.indexOf(what) === 0\n}\n\n// if the string ends with the substring\nexport function ends_with(string, what)\n{\n\tconst index = string.lastIndexOf(what)\n\tif (index < 0)\n\t{\n\t\treturn\n\t}\n\treturn index === string.length - what.length\n}\n\n// repeat string N times\nexport function repeat(what, times)\n{\n\tlet result = ''\n\twhile (times > 0)\n\t{\n\t\tresult += what\n\t\ttimes--\n\t}\n\treturn result\n}\n\n// if the text is blank\nexport function is_blank(text)\n{\n\treturn !exists(text) || !text.replace(/\\s/g, '')\n}\n\n// zips two arrays\nexport function zip(a, b)\n{\n\treturn a.map(function(_, index) \n\t{\n\t\treturn [a[index], b[index]]\n\t})\n}\n\n// extends the first object with \n/* istanbul ignore next: some weird transpiled code, not testable */\nexport function extend(...objects)\n{\n\tconst to   = objects[0]\n\tconst from = objects[1]\n\n\tif (objects.length > 2)\n\t{\n\t\tconst last = objects.pop()\n\t\tconst intermediary_result = extend.apply(this, objects)\n\t\treturn extend(intermediary_result, last)\n\t}\n\n\tfor (let key of Object.keys(from))\n\t{\n\t\tif (typeof from[key] === 'object' && exists(to[key]))\n\t\t{\n\t\t\tto[key] = extend(to[key], from[key])\n\t\t}\n\t\telse\n\t\t{\n\t\t\tto[key] = from[key]\n\t\t}\n\t}\n\n\treturn to\n}\n\n\n/** WEBPACK FOOTER **\n ** G:/work/react-styling/source/helpers.js\n **/","import { starts_with, is_blank, repeat } from './helpers'\n\n// tabulation utilities\nexport default class Tabulator\n{\n\tconstructor(tab)\n\t{\n\t\tthis.tab = tab\n\t}\n\n\t// remove some tabs in the beginning\n\treduce_indentation(line, how_much)\n\t{\n\t\treturn line.substring(this.tab.symbol.length * how_much)\n\t}\n\n\t// how many \"tabs\" are there before content of this line\n\tcalculate_indentation(line)\n\t{\n\t\tconst matches = line.match(this.tab.regexp)\n\n\t\tif (!matches)\n\t\t{\n\t\t\treturn 0\n\t\t}\n\n\t\treturn matches[0].length / this.tab.symbol.length\n\t}\n\n\textract_tabulation(lines)\n\t{\n\t\tlines = lines\n\t\t\t// preserve line indexes\n\t\t\t.map((line, index) =>\n\t\t\t{\n\t\t\t\treturn { line, index }\n\t\t\t})\n\t\t\t// filter out blank lines\n\t\t\t.filter(line => !is_blank(line.line))\n\n\t\t// calculate each line's indentation\n\t\tlines.forEach(line => \n\t\t{\n\t\t\tconst tabs = this.calculate_indentation(line.line)\n\t\t\tconst pure_line = this.reduce_indentation(line.line, tabs)\n\n\t\t\t// check for messed up space indentation\n\t\t\tif (starts_with(pure_line, ' '))\n\t\t\t{\n\t\t\t\tlet reason\n\t\t\t\tif (this.tab.symbol === '\\t')\n\t\t\t\t{\n\t\t\t\t\treason = 'mixed tabs and spaces'\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treason = 'extra leading spaces'\n\t\t\t\t}\n\n\t\t\t\tthrow new Error(`Invalid indentation (${reason}) at line ${line.index}: \"${this.reveal_whitespace(line.line)}\"`)\n\t\t\t}\n\n\t\t\t// check for tabs in spaced intentation\n\t\t\tif (starts_with(pure_line, '\\t'))\n\t\t\t{\n\t\t\t\tlet reason\n\t\t\t\tif (this.tab.symbol === '\\t')\n\t\t\t\t{\n\t\t\t\t\treason = 'extra leading tabs'\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treason = 'mixed tabs and spaces'\n\t\t\t\t}\n\n\t\t\t\tthrow new Error(`Invalid indentation (${reason}) at line ${line.index}: \"${this.reveal_whitespace(line.line)}\"`)\n\t\t\t}\n\n\t\t\tline.tabs          = tabs\n\t\t\tline.original_line = line.line\n\t\t\tline.line          = pure_line\n\t\t})\n\n\t\t// get the minimum indentation level\n\t\tconst minimum_indentation = lines\n\t\t\t.reduce((minimum, line) => Math.min(minimum, line.tabs), Infinity)\n\n\t\t/* istanbul ignore else: do nothing on else */\n\t\t// if there is initial tabulation missing - add it\n\t\tif (minimum_indentation === 0)\n\t\t{\n\t\t\tlines.forEach(function(line)\n\t\t\t{\n\t\t\t\tline.tabs++\n\t\t\t})\n\t\t}\n\t\t// if there is excessive tabulation - trim it\n\t\telse if (minimum_indentation > 1)\n\t\t{\n\t\t\tlines.forEach(function(line)\n\t\t\t{\n\t\t\t\tline.tabs -= minimum_indentation - 1\n\t\t\t})\n\t\t}\n\n\t\t// check for messed up tabulation\n\t\tif (lines[0].tabs !== 1)\n\t\t{\n\t\t\tthrow new Error(`Invalid indentation at line ${lines[0].index}: \"${lines[0].original_line}\"`)\n\t\t}\n\n\t\treturn lines\n\t}\n\n\treveal_whitespace(text)\n\t{\n\t\tconst whitespace_count = text.length - text.replace(/^\\s*/, '').length\n\n\t\tconst whitespace = text.substring(0, whitespace_count + 1)\n\t\t\t.replace(this.tab.regexp_anywhere, '[indent]')\n\t\t\t.replace(/ /g, '[space]')\n\t\t\t.replace(/\\t/g, '[tab]')\n\n\t\tconst rest = text.substring(whitespace_count + 1)\n\n\t\treturn whitespace + rest\n\t}\n}\n\n// decide whether it's tabs or spaces\nTabulator.determine_tabulation = function(lines)\n{\n\tconst substract = pair => pair[0] - pair[1]\n\n\tfunction is_tabulated(line)\n\t{\n\t\t// if we're using tabs for tabulation\n\t\tif (starts_with(line, '\\t'))\n\t\t{\n\t\t\tconst tab = \n\t\t\t{\n\t\t\t\tsymbol: '\\t',\n\t\t\t\tregexp: new RegExp('^(\\t)+', 'g'),\n\t\t\t\tregexp_anywhere: new RegExp('(\\t)+', 'g')\n\t\t\t}\n\n\t\t\treturn tab\n\t\t}\n\t}\n\n\tfunction calculate_leading_spaces(line)\n\t{\n\t\tlet counter = 0\n\t\tline.replace(/^( )+/g, function(match) { counter = match.length })\n\t\treturn counter\n\t}\n\n\t// take all meaningful lines\n\tlines = lines.filter(line => !is_blank(line))\n\n\t// has to be at least two of them\n\tif (lines.length === 0)\n\t{\n\t\tthrow new Error(`Couldn't decide on tabulation type. Not enough lines.`)\n\t}\n\n\t/* istanbul ignore next: not a probable case in styles scenario */\n\tif (lines.length === 1)\n\t{\n\t\tconst tab = is_tabulated(lines[0])\n\t\tif (tab)\n\t\t{\n\t\t\treturn tab\n\t\t}\n\n\t\treturn calculate_leading_spaces(lines[0])\n\t}\n\n\t// if we're using tabs for tabulation\n\tconst tab = is_tabulated(lines[1])\n\tif (tab)\n\t{\n\t\treturn tab\n\t}\n\n\t// take the first two lines,\n\t// calculate their indentation,\n\t// substract it and you've got the tab width\n\tconst tab_width = Math.abs(substract(\n\t\tlines\n\t\t\t.slice(0, 2)\n\t\t\t.map(calculate_leading_spaces)\n\t))\n\n\tif (tab_width === 0)\n\t{\n\t\tthrow new Error(`Couldn't decide on tabulation type. Same indentation.`)\n\t}\n\n\tconst symbol = repeat(' ', tab_width)\n\n\tconst spaced_tab = \n\t{\n\t\tsymbol: symbol,\n\t\tregexp: new RegExp(`^(${symbol})+`, 'g'),\n\t\tregexp_anywhere: new RegExp(`(${symbol})+`, 'g')\n\t}\n\n\treturn spaced_tab\n}\n\n\n/** WEBPACK FOOTER **\n ** G:/work/react-styling/source/tabulator.js\n **/"],"sourceRoot":""}