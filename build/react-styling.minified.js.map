{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///react-styling.minified.js","webpack:///webpack/bootstrap c04982dc127dc8175f98","webpack:///G:/work/react-styling/source/index.js","webpack:///G:/work/react-styling/source/helpers.js","webpack:///G:/work/react-styling/source/tabulator.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","styler","strings","style","i","length","_len","arguments","values","Array","_key","_helpers","exists","parse_json_object","text","replace","style_json","parse_lines","split","expand_modifier_style_classes","_x","_again","lines","tabulator","node_entry_lines","node_ending_lines","from_to","each_node_lines","undefined","is_blank","_tabulator2","determine_tabulation","normalize_initial_tabulation","filter","line","match","map","index","indentation","calculate_indentation","reduce_tabulation","starts_with","Error","trim","result","line_data","line_index","shift","push","zip","slice","name","is_a_modifier","substring","ends_with","styles","line_info","colon_index","indexOf","children_lines","tabulate","json","generate_node_json","_is_a_modifier","reduce","nodes","node","object","own_style","parts","key","value","character","toUpperCase","extend","children","get_node_style","Object","keys","forEach","property","style_property","defineProperty","_tabulator","string","what","lastIndexOf","repeat","times","a","b","_","_x2","_x3","_this","_arguments","to","from","or_more","parameters","last","intermediary_result","_iteratorNormalCompletion","_didIteratorError","_iteratorError","prototype","_step","_iterator","Symbol","iterator","next","done","err","pop","apply","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","protoProps","staticProps","Tabulator","tab","how_much","symbol","matches","regexp","minimum_indentation","minimum","Math","min","Infinity","calculate_leading_spaces","counter","substract","pair","RegExp","tab_width","abs","spaced_tab"],"mappings":"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","file":"react-styling.minified.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"react-styling\"] = factory();\n\telse\n\t\troot[\"react-styling\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"react-styling\"] = factory();\n\telse\n\t\troot[\"react-styling\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t\tvalue: true\n\t});\n\texports['default'] = styler;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _helpers = __webpack_require__(1);\n\t\n\tvar _tabulator = __webpack_require__(2);\n\t\n\tvar _tabulator2 = _interopRequireDefault(_tabulator);\n\t\n\t// using ES6 template strings\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings\n\t\n\tfunction styler(strings) {\n\t\tvar style = '';\n\t\n\t\t// restore the whole string from \"strings\" and \"values\" parts\n\t\tvar i = 0;\n\t\twhile (i < strings.length) {\n\t\t\tstyle += strings[i];\n\t\n\t\t\tfor (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\t\t\tvalues[_key - 1] = arguments[_key];\n\t\t\t}\n\t\n\t\t\tif ((0, _helpers.exists)(values[i])) {\n\t\t\t\tstyle += values[i];\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\n\t\treturn parse_json_object(style);\n\t}\n\t\n\t// converts text to JSON object\n\tfunction parse_json_object(text) {\n\t\t// ignore opening curly braces for now.\n\t\t// maybe support curly braces along with tabulation in future\n\t\ttext = text.replace(/[\\{\\}]/g, '');\n\t\n\t\t// parse text into JSON object\n\t\tvar style_json = parse_lines(text.split('\\n'));\n\t\n\t\t// expand \"modifier\" style classes\n\t\treturn expand_modifier_style_classes(style_json);\n\t}\n\t\n\t// parses lines of text into a JSON object\n\t// (recursive function)\n\tfunction parse_lines(_x) {\n\t\tvar _again = true;\n\t\n\t\t_function: while (_again) {\n\t\t\tvar lines = _x;\n\t\t\ttabulator = node_entry_lines = node_ending_lines = from_to = each_node_lines = undefined;\n\t\t\t_again = false;\n\t\n\t\t\t// return empty object if there are no lines\n\t\t\tif (!lines.length) {\n\t\t\t\treturn {};\n\t\t\t}\n\t\n\t\t\t// ensure there are no blank lines at the start\n\t\t\tif ((0, _helpers.is_blank)(lines[0])) {\n\t\t\t\tlines.shift();\n\t\t\t\t_x = lines;\n\t\t\t\t_again = true;\n\t\t\t\tcontinue _function;\n\t\t\t}\n\t\n\t\t\t// helper class for dealing with tabulation\n\t\t\tvar tabulator = new _tabulator2['default'](_tabulator2['default'].determine_tabulation(lines));\n\t\n\t\t\tlines = tabulator.normalize_initial_tabulation(lines).filter(function (line) {\n\t\t\t\t// ignore blank lines,\n\t\t\t\t// ignore single line comments (//)\n\t\t\t\treturn !(0, _helpers.is_blank)(line) && !line.match(/^[\\s]*\\/\\//);\n\t\t\t}).map(function (line, index) {\n\t\t\t\t// get this line indentation and also trim the indentation\n\t\t\t\tvar indentation = tabulator.calculate_indentation(line);\n\t\t\t\tline = tabulator.reduce_tabulation(line, indentation);\n\t\n\t\t\t\t// check for messed up space tabulation\n\t\t\t\tif ((0, _helpers.starts_with)(line, ' ')) {\n\t\t\t\t\t// #${line_index}\n\t\t\t\t\tthrow new Error('Invalid tabulation (some extra leading spaces) at line: \"' + line + '\"');\n\t\t\t\t}\n\t\n\t\t\t\t// remove any trailing whitespace\n\t\t\t\tline = line.trim();\n\t\n\t\t\t\tvar result = {\n\t\t\t\t\tline: line,\n\t\t\t\t\tindex: index,\n\t\t\t\t\tindentation: indentation\n\t\t\t\t};\n\t\n\t\t\t\treturn result;\n\t\t\t});\n\t\n\t\t\t// determine lines with indentation = 1 (child node entry lines)\n\t\t\tvar node_entry_lines = lines.filter(function (line_data) {\n\t\t\t\treturn line_data.indentation === 1;\n\t\t\t}).map(function (line) {\n\t\t\t\treturn line.index;\n\t\t\t});\n\t\n\t\t\t// deduce corresponding child node ending lines\n\t\t\tvar node_ending_lines = node_entry_lines.map(function (line_index) {\n\t\t\t\treturn line_index - 1;\n\t\t\t});\n\t\t\tnode_ending_lines.shift();\n\t\t\tnode_ending_lines.push(lines.length - 1);\n\t\n\t\t\t// each node boundaries in terms of starting line index and ending line index\n\t\t\tvar from_to = (0, _helpers.zip)(node_entry_lines, node_ending_lines);\n\t\n\t\t\t// now lines are split by nodes\n\t\t\tvar each_node_lines = from_to.map(function (from_to) {\n\t\t\t\treturn lines.slice(from_to[0], from_to[1] + 1);\n\t\t\t});\n\t\n\t\t\treturn each_node_lines.map(function (lines) {\n\t\t\t\t// the first line is the node's name\n\t\t\t\tvar name = lines.shift().line;\n\t\n\t\t\t\t// is it a \"modifier\" style class\n\t\t\t\tvar is_a_modifier = false;\n\t\n\t\t\t\t// detect modifier style classes\n\t\t\t\tif ((0, _helpers.starts_with)(name, '.')) {\n\t\t\t\t\tname = name.substring('.'.length);\n\t\t\t\t\tis_a_modifier = true;\n\t\t\t\t}\n\t\n\t\t\t\t// if someone forgot a trailing colon in the style class name - trim it\n\t\t\t\t// (or maybe these are Python people)\n\t\t\t\tif ((0, _helpers.ends_with)(name, ':')) {\n\t\t\t\t\tname = name.substring(0, name.length - ':'.length)\n\t\t\t\t\t// throw new Error(`Remove the trailing colon at line: ${original_line}`)\n\t\t\t\t\t;\n\t\t\t\t}\n\t\n\t\t\t\t// node's own styles\n\t\t\t\tvar styles = lines.filter(function (line_info) {\n\t\t\t\t\tvar line = line_info.line;\n\t\t\t\t\tvar indentation = line_info.indentation;\n\t\n\t\t\t\t\t// own styles always have indentation of 2\n\t\t\t\t\tif (indentation !== 2) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// detect generic css style line\n\t\t\t\t\tvar colon_index = line.indexOf(':');\n\t\t\t\t\treturn colon_index > 0 && colon_index < line.length - 1 && !(0, _helpers.starts_with)(line, '@');\n\t\t\t\t});\n\t\n\t\t\t\t// this node child nodes and all their children, etc\n\t\t\t\tvar children_lines = lines.filter(function (line_info) {\n\t\t\t\t\treturn styles.indexOf(line_info) < 0;\n\t\t\t\t});\n\t\n\t\t\t\t// convert from line info to lines\n\t\t\t\tstyles = styles.map(function (line_info) {\n\t\t\t\t\treturn line_info.line;\n\t\t\t\t});\n\t\t\t\tchildren_lines = children_lines.map(function (line_info) {\n\t\t\t\t\treturn tabulator.tabulate(line_info.line, line_info.indentation - 1);\n\t\t\t\t});\n\t\n\t\t\t\t// generate JSON object for this node\n\t\t\t\tvar json = generate_node_json(name, styles, children_lines);\n\t\n\t\t\t\tif (is_a_modifier) {\n\t\t\t\t\tjson._is_a_modifier = true;\n\t\t\t\t}\n\t\n\t\t\t\treturn { name: name, json: json };\n\t\t\t}).reduce(function (nodes, node) {\n\t\t\t\tnodes[node.name] = node.json;\n\t\t\t\treturn nodes;\n\t\t\t}, {});\n\t\t}\n\t}\n\t\n\t// a node in style JSON object\n\t// parse lines (using styles) into a JSON object with child nodes of this child node\n\tfunction generate_node_json(name, styles, children_lines) {\n\t\tvar object = {};\n\t\n\t\t// transform styles from text to JSON objects\n\t\tvar own_style = styles.map(function (style) {\n\t\t\tvar parts = style.split(':');\n\t\n\t\t\tvar key = parts[0].trim();\n\t\t\tvar value = parts[1].trim();\n\t\n\t\t\t// transform dashed key to camelCase key (it's required by React)\n\t\t\tkey = key.replace(/([-]{1}[a-z]{1})/g, function (character) {\n\t\t\t\treturn character.substring(1).toUpperCase();\n\t\t\t});\n\t\n\t\t\treturn { key: key, value: value };\n\t\t})\n\t\t// add own styles to the object\n\t\t.reduce(function (own_style, style) {\n\t\t\town_style[style.key] = style.value;\n\t\t\treturn own_style;\n\t\t}, {});\n\t\n\t\t// apply the style to the object itself\n\t\t(0, _helpers.extend)(object, own_style);\n\t\n\t\t// process child lines recursively\n\t\tvar children = parse_lines(children_lines);\n\t\n\t\t// add children to the parent\n\t\t(0, _helpers.extend)(object, children);\n\t\n\t\t// end this block\n\t\treturn object;\n\t}\n\t\n\t// expand modifier style classes\n\tfunction expand_modifier_style_classes(node) {\n\t\tvar style = get_node_style(node);\n\t\n\t\tObject.keys(node)\n\t\t// get all modifier style class nodes\n\t\t.filter(function (name) {\n\t\t\treturn typeof node[name] === 'object' && node[name]._is_a_modifier;\n\t\t})\n\t\t// for each modifier style class node\n\t\t.forEach(function (name) {\n\t\t\t// delete the modifier flags\n\t\t\tdelete node[name]._is_a_modifier;\n\t\n\t\t\t// include parent node styles into the modifier style class node\n\t\t\tnode[name] = (0, _helpers.extend)({}, style, node[name]);\n\t\t});\n\t\n\t\tObject.keys(node)\n\t\t// get all style class nodes\n\t\t.filter(function (name) {\n\t\t\treturn typeof node[name] === 'object';\n\t\t})\n\t\t// for each style class node\n\t\t.forEach(function (name) {\n\t\t\t// recurse\n\t\t\texpand_modifier_style_classes(node[name]);\n\t\t});\n\t\n\t\treturn node;\n\t}\n\t\n\t// extracts root css styles of this style class node\n\tfunction get_node_style(node) {\n\t\treturn Object.keys(node)\n\t\t// get all CSS styles of this style class node\n\t\t.filter(function (property) {\n\t\t\treturn typeof node[property] !== 'object';\n\t\t})\n\t\t// for each CSS style of this style class node\n\t\t.reduce(function (style, style_property) {\n\t\t\tstyle[style_property] = node[style_property];\n\t\t\treturn style;\n\t\t}, {});\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t// if the variable is defined\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t\tvalue: true\n\t});\n\texports.starts_with = starts_with;\n\texports.ends_with = ends_with;\n\texports.repeat = repeat;\n\texports.is_blank = is_blank;\n\texports.zip = zip;\n\texports.extend = extend;\n\tvar exists = function exists(what) {\n\t\treturn typeof what !== 'undefined';\n\t};\n\t\n\texports.exists = exists;\n\t// if the string starts with the substring\n\t\n\tfunction starts_with(string, what) {\n\t\treturn string.indexOf(what) === 0;\n\t}\n\t\n\t// if the string ends with the substring\n\t\n\tfunction ends_with(string, what) {\n\t\tvar index = string.lastIndexOf(what);\n\t\tif (index < 0) {\n\t\t\treturn;\n\t\t}\n\t\treturn index === string.length - what.length;\n\t}\n\t\n\t// repeat string N times\n\t\n\tfunction repeat(what, times) {\n\t\tvar result = '';\n\t\twhile (times > 0) {\n\t\t\tresult += what;\n\t\t\ttimes--;\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t// if the text is blank\n\t\n\tfunction is_blank(text) {\n\t\treturn !text.replace(/\\s/g, '');\n\t}\n\t\n\t// zips two arrays\n\t\n\tfunction zip(a, b) {\n\t\treturn a.map(function (_, index) {\n\t\t\treturn [a[index], b[index]];\n\t\t});\n\t}\n\t\n\t// extends the first object with\n\t\n\tfunction extend(_x, _x2, _x3) {\n\t\tvar _this = this,\n\t\t    _arguments = arguments;\n\t\n\t\tvar _again = true;\n\t\n\t\t_function: while (_again) {\n\t\t\tvar to = _x,\n\t\t\t    from = _x2,\n\t\t\t    or_more = _x3;\n\t\t\tparameters = last = intermediary_result = _iteratorNormalCompletion = _didIteratorError = _iteratorError = undefined;\n\t\t\t_again = false;\n\t\n\t\t\tvar parameters = Array.prototype.slice.call(_arguments, 0);\n\t\n\t\t\tif (exists(or_more)) {\n\t\t\t\tvar last = parameters.pop();\n\t\t\t\tvar intermediary_result = extend.apply(_this, parameters);\n\t\t\t\t// pass undefined as the third argument because of either Babel.js bug, or some other bug\n\t\t\t\t// (the third argument is supplied and is equal to the second argument which is weird)\n\t\t\t\t_this = undefined;\n\t\t\t\t_arguments = [_x = intermediary_result, _x2 = last, _x3 = undefined];\n\t\t\t\t_again = true;\n\t\t\t\tcontinue _function;\n\t\t\t}\n\t\n\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\tvar _didIteratorError = false;\n\t\t\tvar _iteratorError = undefined;\n\t\n\t\t\ttry {\n\t\t\t\tfor (var _iterator = Object.keys(from)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\tvar key = _step.value;\n\t\n\t\t\t\t\tif (typeof from[key] === 'object' && exists(to[key])) {\n\t\t\t\t\t\tto[key] = extend(to[key], from[key]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tto[key] = from[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError = true;\n\t\t\t\t_iteratorError = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator['return']) {\n\t\t\t\t\t\t_iterator['return']();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn to;\n\t\t}\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _helpers = __webpack_require__(1);\n\t\n\t// tabulation utilities\n\t\n\tvar Tabulator = (function () {\n\t\tfunction Tabulator(tab) {\n\t\t\t_classCallCheck(this, Tabulator);\n\t\n\t\t\tthis.tab = tab;\n\t\t}\n\t\n\t\t_createClass(Tabulator, [{\n\t\t\tkey: 'tabulate',\n\t\n\t\t\t// // has tab in the beginning\n\t\t\t// is_tabulated(line)\n\t\t\t// {\n\t\t\t// \treturn starts_with(line, this.tab.symbol)\n\t\t\t// }\n\t\n\t\t\t// add one tab in the beginning\n\t\t\tvalue: function tabulate(line) {\n\t\t\t\tvar how_much = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];\n\t\n\t\t\t\treturn (0, _helpers.repeat)(this.tab.symbol, how_much) + line;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'reduce_tabulation',\n\t\n\t\t\t// remove some tabs in the beginning\n\t\t\tvalue: function reduce_tabulation(line) {\n\t\t\t\tvar how_much = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];\n\t\n\t\t\t\treturn line.substring(this.tab.symbol.length * how_much);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'calculate_indentation',\n\t\n\t\t\t// how many \"tabs\" are there before content of this line\n\t\t\tvalue: function calculate_indentation(line) {\n\t\t\t\tvar matches = line.match(this.tab.regexp);\n\t\n\t\t\t\tif (!matches) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\n\t\t\t\treturn matches[0].length / this.tab.symbol.length;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'normalize_initial_tabulation',\n\t\t\tvalue: function normalize_initial_tabulation(lines) {\n\t\t\t\tvar _this = this;\n\t\n\t\t\t\t// filter out blank lines,\n\t\t\t\t// calculate each line's indentation,\n\t\t\t\t// and get the minimum one\n\t\t\t\tvar minimum_indentation = lines.filter(function (line) {\n\t\t\t\t\treturn !(0, _helpers.is_blank)(line);\n\t\t\t\t}).map(function (line) {\n\t\t\t\t\treturn _this.calculate_indentation(line);\n\t\t\t\t}).reduce(function (minimum, indentation) {\n\t\t\t\t\treturn Math.min(minimum, indentation);\n\t\t\t\t}, Infinity);\n\t\n\t\t\t\t// if there is initial tabulation missing - add it\n\t\t\t\tif (minimum_indentation === 0) {\n\t\t\t\t\tlines = lines.map(function (line) {\n\t\t\t\t\t\treturn _this.tabulate(line);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t// if there is excessive tabulation - trim it\n\t\t\t\telse if (minimum_indentation > 1) {\n\t\t\t\t\tlines = lines.map(function (line) {\n\t\t\t\t\t\treturn _this.reduce_tabulation(line, minimum_indentation - 1);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\n\t\t\t\treturn lines;\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Tabulator;\n\t})();\n\t\n\texports['default'] = Tabulator;\n\t\n\t// decide whether it's tabs or spaces\n\tTabulator.determine_tabulation = function (lines) {\n\t\tvar substract = function substract(pair) {\n\t\t\treturn pair[0] - pair[1];\n\t\t};\n\t\n\t\tfunction calculate_leading_spaces(line) {\n\t\t\tvar counter = 0;\n\t\t\tline.replace(/^( )+/g, function (match) {\n\t\t\t\tcounter = match.length;\n\t\t\t});\n\t\t\treturn counter;\n\t\t}\n\t\n\t\t// take all meaningful lines\n\t\tlines = lines.filter(function (line) {\n\t\t\treturn !(0, _helpers.is_blank)(line);\n\t\t});\n\t\n\t\t// has to be at least two of them\n\t\tif (lines.length < 2) {\n\t\t\tthrow new Error('Couldn\\'t decide on tabulation type. Not enough lines.');\n\t\t}\n\t\n\t\t// if we're using tabs for tabulation\n\t\tif ((0, _helpers.starts_with)(lines[1], '\\t')) {\n\t\t\tvar tab = {\n\t\t\t\tsymbol: '\\t',\n\t\t\t\tregexp: new RegExp('^(\\t)+', 'g')\n\t\t\t};\n\t\n\t\t\treturn tab;\n\t\t}\n\t\n\t\t// take the first two lines,\n\t\t// calculate their indentation,\n\t\t// substract it and you've got the tab width\n\t\tvar tab_width = Math.abs(substract(lines.slice(0, 2).map(calculate_leading_spaces)));\n\t\n\t\tif (tab_width === 0) {\n\t\t\tthrow new Error('Couldn\\'t decide on tabulation type. Invalid tabulation.');\n\t\t}\n\t\n\t\tvar symbol = (0, _helpers.repeat)(' ', tab_width);\n\t\n\t\tvar spaced_tab = {\n\t\t\tsymbol: symbol,\n\t\t\tregexp: new RegExp('^(' + symbol + ')+', 'g')\n\t\t};\n\t\n\t\treturn spaced_tab;\n\t};\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** react-styling.minified.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap c04982dc127dc8175f98\n **/","import { exists, starts_with, ends_with, is_blank, zip, extend } from './helpers'\nimport Tabulator from './tabulator'\n\n// using ES6 template strings\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings\nexport default function styler(strings, ...values)\n{\n\tlet style = ''\n\n\t// restore the whole string from \"strings\" and \"values\" parts\n\tlet i = 0\n\twhile (i < strings.length)\n\t{\n\t\tstyle += strings[i]\n\t\tif (exists(values[i]))\n\t\t{\n\t\t\tstyle += values[i]\n\t\t}\n\t\ti++\n\t}\n\n\treturn parse_json_object(style)\n}\n\n// converts text to JSON object\nfunction parse_json_object(text)\n{\n\t// ignore opening curly braces for now.\n\t// maybe support curly braces along with tabulation in future\n\ttext = text.replace(/[\\{\\}]/g, '')\n\n\t// parse text into JSON object\n\tconst style_json = parse_lines(text.split('\\n'))\n\n\t// expand \"modifier\" style classes\n\treturn expand_modifier_style_classes(style_json)\n}\n\n// parses lines of text into a JSON object\n// (recursive function)\nfunction parse_lines(lines)\n{\n\t// return empty object if there are no lines\n\tif (!lines.length)\n\t{\n\t\treturn {}\n\t}\n\n\t// ensure there are no blank lines at the start\n\tif (is_blank(lines[0]))\n\t{\n\t\tlines.shift()\n\t\treturn parse_lines(lines)\n\t}\n\n\t// helper class for dealing with tabulation\n\tconst tabulator = new Tabulator(Tabulator.determine_tabulation(lines))\n\n\tlines = tabulator.normalize_initial_tabulation(lines)\n\t.filter(function(line)\n\t{\n\t\t// ignore blank lines,\n\t\t// ignore single line comments (//)\n\t\treturn !is_blank(line) && !line.match(/^[\\s]*\\/\\//)\n\t})\n\t.map(function(line, index)\n\t{\n\t\t// get this line indentation and also trim the indentation\n\t\tconst indentation = tabulator.calculate_indentation(line)\n\t\tline = tabulator.reduce_tabulation(line, indentation)\n\n\t\t// check for messed up space tabulation\n\t\tif (starts_with(line, ' '))\n\t\t{\n\t\t\t// #${line_index}\n\t\t\tthrow new Error(`Invalid tabulation (some extra leading spaces) at line: \"${line}\"`)\n\t\t}\n\n\t\t// remove any trailing whitespace\n\t\tline = line.trim()\n\n\t\tconst result = \n\t\t{\n\t\t\tline          : line,\n\t\t\tindex         : index,\n\t\t\tindentation   : indentation\n\t\t}\n\n\t\treturn result\n\t})\n\n\t// determine lines with indentation = 1 (child node entry lines)\n\tconst node_entry_lines = lines.filter(line_data => line_data.indentation === 1).map(line => line.index)\n\n\t// deduce corresponding child node ending lines\n\tconst node_ending_lines = node_entry_lines.map(line_index => line_index - 1)\n\tnode_ending_lines.shift()\n\tnode_ending_lines.push(lines.length - 1)\n\n\t// each node boundaries in terms of starting line index and ending line index\n\tconst from_to = zip(node_entry_lines, node_ending_lines)\n\n\t// now lines are split by nodes\n\tconst each_node_lines = from_to.map(from_to => lines.slice(from_to[0], from_to[1] + 1))\n\n\treturn each_node_lines.map(function(lines)\n\t{\n\t\t// the first line is the node's name\n\t\tlet name = lines.shift().line\n\n\t\t// is it a \"modifier\" style class\n\t\tlet is_a_modifier = false\n\n\t\t// detect modifier style classes\n\t\tif (starts_with(name, '.'))\n\t\t{\n\t\t\tname = name.substring('.'.length)\n\t\t\tis_a_modifier = true\n\t\t}\n\n\t\t// if someone forgot a trailing colon in the style class name - trim it\n\t\t// (or maybe these are Python people)\n\t\tif (ends_with(name, ':'))\n\t\t{\n\t\t\tname = name.substring(0, name.length - ':'.length)\n\t\t\t// throw new Error(`Remove the trailing colon at line: ${original_line}`)\n\t\t}\n\n\t\t// node's own styles\n\t\tlet styles = lines.filter(function(line_info)\n\t\t{\n\t\t\tconst line        = line_info.line\n\t\t\tconst indentation = line_info.indentation\n\n\t\t\t// own styles always have indentation of 2\n\t\t\tif (indentation !== 2)\n\t\t\t{\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// detect generic css style line\n\t\t\tconst colon_index = line.indexOf(':')\n\t\t\treturn (colon_index > 0 && colon_index < line.length - 1) && !starts_with(line, '@')\n\t\t})\n\n\t\t// this node child nodes and all their children, etc\n\t\tlet children_lines = lines.filter(function(line_info)\n\t\t{\n\t\t\treturn styles.indexOf(line_info) < 0\n\t\t})\n\n\t\t// convert from line info to lines\n\t\tstyles = styles.map(line_info => line_info.line)\n\t\tchildren_lines = children_lines.map(line_info => tabulator.tabulate(line_info.line, line_info.indentation - 1))\n\n\t\t// generate JSON object for this node\n\t\tconst json = generate_node_json(name, styles, children_lines)\n\n\t\tif (is_a_modifier)\n\t\t{\n\t\t\tjson._is_a_modifier = true\n\t\t}\n\n\t\treturn { name, json }\n\t})\n\t.reduce(function(nodes, node)\n\t{\n\t\tnodes[node.name] = node.json\n\t\treturn nodes\n\t}, \n\t{})\n}\n\n// a node in style JSON object\n// parse lines (using styles) into a JSON object with child nodes of this child node\nfunction generate_node_json(name, styles, children_lines)\n{\n\tconst object = {}\n\n\t// transform styles from text to JSON objects\n\tconst own_style = styles.map(function(style)\n\t{\n\t\tconst parts = style.split(':')\n\n\t\tlet key     = parts[0].trim()\n\t\tconst value = parts[1].trim()\n\n\t\t// transform dashed key to camelCase key (it's required by React)\n\t\tkey = key.replace(/([-]{1}[a-z]{1})/g, character => character.substring(1).toUpperCase())\n\n\t\treturn { key, value }\n\t})\n\t// add own styles to the object\n\t.reduce(function(own_style, style)\n\t{\n\t\town_style[style.key] = style.value\n\t\treturn own_style\n\t}, \n\t{})\n\n\t// apply the style to the object itself\n\textend(object, own_style)\n\n\t// process child lines recursively\n\tconst children = parse_lines(children_lines)\n\n\t// add children to the parent\n\textend(object, children)\n\n\t// end this block\n\treturn object\n}\n\n// expand modifier style classes\nfunction expand_modifier_style_classes(node)\n{\n\tconst style = get_node_style(node)\n\n\tObject.keys(node)\n\t// get all modifier style class nodes\n\t.filter(name => typeof(node[name]) === 'object' && node[name]._is_a_modifier)\n\t// for each modifier style class node\n\t.forEach(function(name)\n\t{\n\t\t// delete the modifier flags\n\t\tdelete node[name]._is_a_modifier\n\n\t\t// include parent node styles into the modifier style class node\n\t\tnode[name] = extend({}, style, node[name])\n\t})\n\n\tObject.keys(node)\n\t// get all style class nodes\n\t.filter(name => typeof(node[name]) === 'object')\n\t// for each style class node\n\t.forEach(function(name)\n\t{\n\t\t// recurse\n\t\texpand_modifier_style_classes(node[name])\n\t})\n\n\treturn node\n}\n\n// extracts root css styles of this style class node\nfunction get_node_style(node)\n{\n\treturn Object.keys(node)\n\t// get all CSS styles of this style class node\n\t.filter(property => typeof(node[property]) !== 'object')\n\t// for each CSS style of this style class node\n\t.reduce(function(style, style_property)\n\t{\n\t\tstyle[style_property] = node[style_property]\n\t\treturn style\n\t}, \n\t{})\n}\n\n\n/** WEBPACK FOOTER **\n ** G:/work/react-styling/source/index.js\n **/","// if the variable is defined\nexport const exists = what => typeof what !== 'undefined'\n\n// if the string starts with the substring\nexport function starts_with(string, what)\n{\n\treturn string.indexOf(what) === 0\n}\n\n// if the string ends with the substring\nexport function ends_with(string, what)\n{\n\tconst index = string.lastIndexOf(what)\n\tif (index < 0)\n\t{\n\t\treturn\n\t}\n\treturn index === string.length - what.length\n}\n\n// repeat string N times\nexport function repeat(what, times)\n{\n\tlet result = ''\n\twhile (times > 0)\n\t{\n\t\tresult += what\n\t\ttimes--\n\t}\n\treturn result\n}\n\n// if the text is blank\nexport function is_blank(text)\n{\n\treturn !text.replace(/\\s/g, '')\n}\n\n// zips two arrays\nexport function zip(a, b)\n{\n\treturn a.map(function(_, index) \n\t{\n\t\treturn [a[index], b[index]]\n\t})\n}\n\n// extends the first object with \nexport function extend(to, from, or_more)\n{\n\tconst parameters = Array.prototype.slice.call(arguments, 0)\n\n\tif (exists(or_more))\n\t{\n\t\tconst last = parameters.pop()\n\t\tconst intermediary_result = extend.apply(this, parameters)\n\t\t// pass undefined as the third argument because of either Babel.js bug, or some other bug\n\t\t// (the third argument is supplied and is equal to the second argument which is weird)\n\t\treturn extend(intermediary_result, last, undefined)\n\t}\n\n\tfor (let key of Object.keys(from))\n\t{\n\t\tif (typeof from[key] === 'object' && exists(to[key]))\n\t\t{\n\t\t\tto[key] = extend(to[key], from[key])\n\t\t}\n\t\telse\n\t\t{\n\t\t\tto[key] = from[key]\n\t\t}\n\t}\n\n\treturn to\n}\n\n\n/** WEBPACK FOOTER **\n ** G:/work/react-styling/source/helpers.js\n **/","import { starts_with, is_blank, repeat } from './helpers'\n\n// tabulation utilities\nexport default class Tabulator\n{\n\tconstructor(tab)\n\t{\n\t\tthis.tab = tab\n\t}\n\n\t// // has tab in the beginning\n\t// is_tabulated(line)\n\t// {\n\t// \treturn starts_with(line, this.tab.symbol)\n\t// }\n\n\t// add one tab in the beginning\n\ttabulate(line, how_much = 1)\n\t{\n\t\treturn repeat(this.tab.symbol, how_much) + line\n\t}\n\n\t// remove some tabs in the beginning\n\treduce_tabulation(line, how_much = 1)\n\t{\n\t\treturn line.substring(this.tab.symbol.length * how_much)\n\t}\n\n\t// how many \"tabs\" are there before content of this line\n\tcalculate_indentation(line)\n\t{\n\t\tconst matches = line.match(this.tab.regexp)\n\n\t\tif (!matches)\n\t\t{\n\t\t\treturn 0\n\t\t}\n\n\t\treturn matches[0].length / this.tab.symbol.length\n\t}\n\n\tnormalize_initial_tabulation(lines)\n\t{\n\t\t// filter out blank lines,\n\t\t// calculate each line's indentation,\n\t\t// and get the minimum one\n\t\tconst minimum_indentation = lines\n\t\t\t.filter(line => !is_blank(line))\n\t\t\t.map(line => this.calculate_indentation(line))\n\t\t\t.reduce((minimum, indentation) => Math.min(minimum, indentation), Infinity)\n\n\t\t// if there is initial tabulation missing - add it\n\t\tif (minimum_indentation === 0)\n\t\t{\n\t\t\tlines = lines.map(line => this.tabulate(line))\n\t\t}\n\t\t// if there is excessive tabulation - trim it\n\t\telse if (minimum_indentation > 1)\n\t\t{\n\t\t\tlines = lines.map(line => this.reduce_tabulation(line, minimum_indentation - 1))\n\t\t}\n\n\t\treturn lines\n\t}\n}\n\n// decide whether it's tabs or spaces\nTabulator.determine_tabulation = function(lines)\n{\n\tconst substract = pair => pair[0] - pair[1]\n\n\tfunction calculate_leading_spaces(line)\n\t{\n\t\tlet counter = 0\n\t\tline.replace(/^( )+/g, function(match) { counter = match.length })\n\t\treturn counter\n\t}\n\n\t// take all meaningful lines\n\tlines = lines.filter(line => !is_blank(line))\n\n\t// has to be at least two of them\n\tif (lines.length < 2)\n\t{\n\t\tthrow new Error(`Couldn't decide on tabulation type. Not enough lines.`)\n\t}\n\n\t// if we're using tabs for tabulation\n\tif (starts_with(lines[1], '\\t'))\n\t{\n\t\tconst tab = \n\t\t{\n\t\t\tsymbol: '\\t',\n\t\t\tregexp: new RegExp(`^(\\t)+`, 'g')\n\t\t}\n\n\t\treturn tab\n\t}\n\n\t// take the first two lines,\n\t// calculate their indentation,\n\t// substract it and you've got the tab width\n\tconst tab_width = Math.abs(substract(\n\t\tlines\n\t\t\t.slice(0, 2)\n\t\t\t.map(calculate_leading_spaces)\n\t))\n\n\tif (tab_width === 0)\n\t{\n\t\tthrow new Error(`Couldn't decide on tabulation type. Invalid tabulation.`)\n\t}\n\n\tconst symbol = repeat(' ', tab_width)\n\n\tconst spaced_tab = \n\t{\n\t\tsymbol: symbol,\n\t\tregexp: new RegExp(`^(${symbol})+`, 'g')\n\t}\n\n\treturn spaced_tab\n}\n\n\n/** WEBPACK FOOTER **\n ** G:/work/react-styling/source/tabulator.js\n **/"],"sourceRoot":""}